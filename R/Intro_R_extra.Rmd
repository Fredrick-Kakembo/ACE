---
title:  "Introduction to R"
output: rmarkdown::github_document
---


# Getting Started

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. To execute a single line in the chunk, do *Ctrl+Enter*.

```{r, eval=FALSE}
plot(cars)
```

## Basic Syntax

Variables are assigned using an arrow `<-` or an equals sign `=`.  `<-` is more common. Enter variable by itself to print, or use print statement.

```{r}
a <- 5
b <- 7
c_variable_1 <- a + b
print(c_variable_1)
```


Variable names have to follow some rules.
- allowed characters: alphanumeric, '.' and '_' - *no spaces*
- must start with a letter or '.'
- if it starts with '.', the second character cannot be a number
- of any length - easiest if you use meaningful names, so your code is readable by others


In an R session, objects are created in a workspace.

```{r}
ls()
rm(a,b)
ls()
```

## Saving your work
By default the session is saved in a file called `.RData`.  This file is a special R binary format.  Because it starts with a '.', you won't see it if you do `ls` in your terminal, but it does show up in the RStudio Files browser.
RStudio will also ask you if you want to save your workspace when you quit (can turn this off in Tools > Global Options).
```{r, eval=F}
x <- 1:5
save.image()
rm(c_variable_1)
ls()
load('.RData')
ls()
```

Non-default save location and saving single objects (also in same R binary format)
```{r, eval=F}
save.image("my.RData")
ls()
saveRDS(x, "x.rds")
y <- readRDS("x.rds")
```

### Saving commands to a script
For reproducibility, it is also wise to save all of the commands that you use to a script.  In RStudio, the History pane shows the commands you have executed.

Open a new R Script File (Green plus icon in top left), and put some commands in it (maybe from the first chunk above) and Save As *script1.R*.  Then, from within R, you can `source` the script to run the commands.

```{r, eval=F}
source('script1.R')
```

You can also run the script from the unix command line/terminal.  RStudio has a convenient terminal window as well.

```{bash, eval=F}
Rscript script1.R
```

## Add-on packages
Most of the time, you will not be able to do all of your analysis with plain base R.  You will need some additional packages.  In RStudio, you can use the *Packages* pane to see what packages are on your system and install new ones.  But, you can also install through the console.
```{r, eval=F}
sessionInfo()
install.packages('wesanderson')
library(wesanderson)
```


## Help!
You can get help on an r object using `?` or by searching in the help window in RStudio.
```{r}
?rep
?sample
```

Sometimes you will get an error or warning message when you run your code. [Common errors](http://varianceexplained.org/courses/errors/) that you may see. [^3]
```{r, eval=F}
foo(5,3)
```

Sometimes, the error will be more cryptic to you.  In this case, copy the error message, and try searching for it online either in a general search, or on the Stack Exchange sites like https://stackoverflow.com/questions/tagged/r or https://stats.stackexchange.com/ or the Biostar sites https://support.bioconductor.org/ and https://www.biostars.org/.

# Vectors

The basic data structures in R are vectors, data frames, matrices, lists, and functions.  Add-on packages may implement their own classes of data structures as well.

- Vectors are the simplest data structures in R.
- Different types of vectors: numeric, character, logical, factor,...

## Vector basics

- **numeric** vectors are collections of decimal numbers
- **character** vectors are collections of strings which should be in single or double quotes to differentiate from variables in the workspace

```{r}
num_vector <- c(7,3,4,6,2)
char_vector <- c("volleyball", "  badminton", "netball", "tennis")
```


### Accessing elements
- vectors are 1-D
- access their elements by their index with 1-based numbering
- access multiple elements with index vector notation
- negative indexes remove elements
- `:` symbol makes a vector of a regular sequence
- combine indexing with assignment

```{r}
num_vector[3]
num_vector[c(2,5)]
num_vector[2:5]
num_vector[-4]
num_vector[4] <- 37.5
```


### Getting info about vectors

*Check* which type of vector (or any data structure you have) with `class` or `typeof`.  In general, checking for class is sufficient.
```{r}
y_float <- c(5, sqrt(7), 3/21)
y_float
class(y_float)
typeof(y_float)
```


*Check* the beginning or end of a vector with `head` and `tail`
```{r}
months <- month.name #constant in R
head(months)
tail(months)
```



### Vector operations
Most operators/functions are vectorized - meaning they can take a vector of any length and perform the same operation element-wise.

*Example*: manipulate strings (useful for data cleanup) - substitute, trim
```{r}
char_vector
gsub("a", "ae", char_vector)
char_vector <- trimws(char_vector)
char_vector
```


*Example*: arithmetic operations
```{r}
x <- -1:12
x
5 + x/2
x %% 2
y <- c(0.2, 0.5)
x+y
```

- What happened with `x+y`??
  - shorter vectors are "recycled" in arithmetic operations, so *be careful* if this is not what you intend.
  - *Check* the length of vectors
```{r}
length(x)
length(y)
```


## Logical, Factor, and Missing Value Vectors

### Logical vectors
We can ask questions about our data, and filter based on the answers.

- `which` returns the indexes of the *TRUE* elements of a logical vector
- `!` negates
- can filter a vector based on a logical expression
```{r}
x
x > 5
gt_5 <- x > 5
which(gt_5)
which(!gt_5)
!gt_5
x[x>5]
```

### Missing and other special values
Usually you see these values because something is wrong with your code or unexpected or missing in input data.

- `NA`: *Not Available* - indicates a value that is missing
- `NaN`: *Not a Number*; `Inf` and `-Inf`: *positive* and *negative infinity* [^1]

```{r}
sqrt(-9)
1/0
var(8)
mean(c(7, 2.75, 32, 'a'))
```

**Warning** messages produced for some operations ↑↑

- `NULL`: null object - often used for undefined values.  Unlike others, this object doesn't exist
```{r}
y_null <- c(7, 2.75, 32, NULL)
y_na <- c(NA, 2.75, 7, 32)
y_inf <- c(7, 2.75, Inf, 32)
mean(y_null)
mean(y_na)
mean(y_inf)
```

*Check* for value types using `is` functions
```{r}
which(is.na(y_na))
which(is.finite(y_inf))
is.numeric(c(7, 2.75, 32, 'a'))
```


- *Exercise*: Count the number of `NA` elements in this vector `c(34, 56, 55, 87, NA, 4, 77, NA, 21, NA, 39)`
```{r, class.source='hidecode'}
x <- c(34, 56, 55, 87, NA, 4, 77, NA, 21, NA, 39)
length(which(is.na(x)))

## This also works!
sum(is.na(x))
```

### Factors
Factor vectors are often used for discrete or categorical data [^2].  

**The Good**
Factors have additional structure that gives them an ordering.  The ordering of the factor vector is called its **levels**.  You can convert character vectors to factors using `factor` and the reverse using `as.character`.

```{r}
time_of_day <- c("evening", "midnight", "dawn", "dusk", "midday")
sort(time_of_day)
time_of_day <- factor(time_of_day, levels=c("midnight", "dawn", "midday", "dusk", "evening"))
class(time_of_day)
```

*Exercises*
- What does `as.numeric` return for the factor vector?
- What data type does `levels` return?
```{r, class.source='hidecode'}
as.numeric(time_of_day)
levels(time_of_day)
```


**The Bad**
Factors can be confusing because they appear to be regular character vectors, but the ordering can cause methods to behave in unexpected ways.  To make matters worse, R has an unfortunate default setting which sets strings as factor vectors in some situations.  We will turn this off, and it's recommended to do this for all future R code.[^4]

```{r}
options(stringsAsFactors=FALSE)
```


[Exercises](./Intro_R_exercises.nb.html)

### Creating a data frame

We use data frames to organize related data.

```{r}
smoker = factor(rep(c("smoker", "non-smoker"), each=50))
smoker_numeric = as.numeric(smoker)
x = rnorm(100)
risk = x + 2*smoker_numeric
```

We have two variables, `risk` and `smoker` that are related. We can make a data frame out of them:

```{r}
smoker_risk = data.frame(smoker = smoker, risk = risk)
head(smoker_risk)
```

R also has plotting shortcuts that work with data frames to simplify plotting

```{r}
plot( risk ~ smoker, data=smoker_risk)
```



# File IO, Data Frames, and Data Cleanup

## Reading in tabular data
### Excel file
In RStudio, File > Import Dataset > From Excel

### Text file
In RStudio, File > Import Dataset > From Text (readr) . Import *brauer2007_messy.csv*.  The `View` command shows you the table in a spreadsheet view. 
```{r}
library(readr)
orig <- read_delim("brauer2007_dataset.txt",  "\t", escape_double = FALSE, trim_ws = TRUE)
View(orig)
```

### Dataset
- From [Brauer et al. Coordination of Growth Rate, Cell Cycle, Stress Response, and Metabolic Activity in Yeast (2008) Mol Biol Cell 19:352-367](http://www.molbiolcell.org/content/19/1/352.abstract).  
- Examined the relationship between growth rate and gene expression in yeast cultures limited by one of six different nutrients (glucose, leucine, ammonium, sulfate, phosphate, uracil).
- More here [^5]. 
- Gene expression microarray dataset where every row represents a gene, and (some of) the columns represent the gene's expression in a different sample.
- **Our goal** is to clean up this dataset, so we can analyse how the genes respond to the nutrient restriction and growth rates.


## Data frames (and lists)

```{r}
class(orig)
```

- A data frame is a specific type of **list**.
- A **list** is a general type of vector.  It can hold items from any data types or class, and the items can have different dimensions.
- Data frames have some restrictions:
  - can only hold vectors, other data frames, and matrices - we will just discuss data frames made up of vectors
  - the vectors must all have the *same length*


### Accessing elements
- data frames are 2-D
- access elements by specifying indexes `[row,column]`
- access multiple rows or columns by vector of indexes
- with `[` notation, leaving a field blank means selecting 'all'
- access columns by using `$` notation and column names

```{r}
orig[3,4]
orig[4:6,4:6]
orig[500,]
head(orig$NAME)
```

The `NAME` column actually represents multiple variables in a single element!
- gene name
- biologic process
- molecular function
- systematic id
- another numerical id (not mentioned in the paper)

In R, it's best if each column represents a single variable.  So, let's *clean this up*.

We will use `%>%` from **magrittr** to successively cleanup `orig` with functions from **tidyr** and **dplyr**.

```{r}
library(magrittr)
library(tidyr)
library(dplyr)

clean <- orig %>%
  separate(NAME, c("name", "bp", "mf", "systematic_id", "numerical_id"), sep="\\|\\|")
```

- The LHS of the `%>%` becomes the first argument of the RHS.

```{r}
head(clean$bp)
head(clean$systematic_id)
```

- Extra whitespace!  *Clean this* and replace empty elements with `NA`.

```{r}
clean <- orig %>%
  separate(NAME, c("name", "bp", "mf", "systematic_id", "numerical_id"), sep="\\|\\|") %>%
  mutate_at(.vars=vars(name:systematic_id), trimws) %>% 
  na_if("")
head(clean$name)
```

Also, let's *clean up* columns that we aren't going to use with `select`.

```{r}
clean <- orig %>%
  separate(NAME, c("name", "bp", "mf", "systematic_id", "numerical_id"), sep="\\|\\|") %>%
  mutate_at(.vars=vars(name:systematic_id), trimws) %>%
  na_if("") %>%
  select(name, G0.05)
head(clean)
```


### Inspecting the data

Get the dimensions of the data frame.

```{r}
dim(clean)
nrow(clean)
ncol(clean)
colnames(clean)
```

Sample names
- First letter is nutrient
- Number is the growth rate
- elements are the expression 

**Wide** format  
- one row per gene; columns 1 to 4 identify the gene  
- one column per sample - measurements/observations of the gene expression

**Long** format  
- every row represents a single observation  
- every column represents a variable

Let's convert to long by using `gather` to "gather up" the observation columns.  The syntax is `gather(key, value, columns)`.
```{r}
clean <- orig %>%
  separate(NAME, c("name", "bp", "mf", "systematic_id", "numerical_id"), sep="\\|\\|") %>%
  mutate_at(.vars=vars(name:systematic_id), trimws) %>%
  na_if("") %>%
  select(-GID, -YORF, -GWEIGHT, -numerical_id) %>%
  gather(sample,expression, G0.05:U0.3)
```

The sample names now contain 2 pieces of information - the nutrient and the growth rate?  How do we *clean* this up?
```{r, source='hidecode'}
clean <- orig %>%
  separate(NAME, c("name", "bp", "mf", "systematic_id", "numerical_id"), sep="\\|\\|") %>%
  mutate_at(.vars=vars(name:systematic_id), trimws) %>%
  na_if("") %>%
  select(-GID, -YORF, -GWEIGHT, -numerical_id) %>%
  gather(sample,expression, G0.05:U0.3) %>%
  separate(sample, c("nutrient", "rate"), sep = 1, convert = TRUE)
```

### Saving a data frame

The most portable way to save a data frame is to use one of the `write` functions to save it as plain text.

```{r eval=FALSE}
write.csv(clean, "brauer2007_cleaned.csv")
write.table(clean, 'brauer2007_cleaned.txt', sep='\t', row.names = F, quote=F, na="")
```

- If the data frame is very large, and you are only going to use it within R (i.e., you are not sharing it with others, just using it to produce some processed output), it may be more efficient to save it as an R binary object.  How would you do that?

# Summarizing and Plotting Data

We have a clean dataset, but it's still A LOT of data.

## Aggregating data

We can use `aggregate` from base stats or `group_by` `summarise` from dplyr
```{r}
head(aggregate(clean$expression, by=list( clean$name), mean))
# or
group_by(clean, name) %>%
  summarise(mean=mean(expression)) %>%
  head
```


### Subsetting
We saw with vectors that we could ask questions about data and get logical values in return.  Since data frames are made up of vectors, we can use these logical values to filter the data - this is much easier now that the data is in *long* format.

Two functions commonly used are `subset` and `filter`.  We will use `filter` from dplyr as it is more robust.
```{r}
filter(clean, nutrient == 'L' & rate == 0.05 & expression > 3)
```

## Plotting with ggplot2
```{r}
library(ggplot2)

filter(clean, name=="LEU1") %>%
  ggplot(aes(x=rate, y=expression, color=nutrient)) + geom_point()
```

```{r}
filter(clean, bp=="leucine biosynthesis") %>%
  ggplot(aes(x=rate, y=expression, color=nutrient)) + geom_point() + facet_wrap(~name)
```

```{r}
filter(clean, bp=="leucine biosynthesis") %>%
  ggplot(aes(x=rate, y=expression, color=nutrient)) + geom_point() + facet_wrap(~name) + geom_smooth(method="lm", se=F)
```


# Shiny!

- [Example app for annotation of copy number variations](https://github.com/gzhmat/ShinyCNV)

- Simple example modified from https://bookdown.org/yihui/rmarkdown/shiny-widgets.html#the-shinyapp-function

```{r}
library(shiny)
clean <- read_csv("brauer2007_cleaned.csv")

shinyApp(
  ui = fluidPage(
    fluidRow(style = "padding-bottom: 20px;",
             column(4, selectInput('bp', 'Biologic Process', sort(unique(clean$bp))))
    ),
    fluidRow(
      plotOutput('gexplot', height = "400px")  
    )
  ),
  
  server = function(input, output, session) {
    fdata <- reactive({
      filter(clean, bp==input$bp)
    })
    output$gexplot = renderPlot(height = 400, {
      fdata() %>%
        ggplot(aes(x=rate, y=expression, color=nutrient)) + geom_point() + facet_wrap(~name) + geom_smooth(method="lm", se=F)
    })
  }
)

```

<!-- Footnotes -->
[^1]: These are part of the IEEE standard for floating point numbers.
[^2]: Underneath, factors are mappings from an integer vector to a character
 vector.
[^3]: Interesting statistical analysis of the [most common R errors](https:/
/github.com/noamross/zero-dependency-problems/blob/master/misc/stack-overflo
w-common-r-errors.md).
[^4]: To make things easier, you can make a file called '.Rprofile' in your
home directory, and put this command there.
[^5]: "The authors examine the relationship between growth rate and gene expression in yeast cultures limited by one of six different nutrients (glucose, leucine, ammonium, sulfate, phosphate, uracil). If you give yeast a rich media loaded with nutrients except restrict the supply of a single nutrient, you can control the growth rate to any rate you choose. By starving yeast of specific nutrients you can find genes that:

    Raise or lower their expression in response to growth rate. Growth-rate dependent expression patterns can tell us a lot about cell cycle control, and how the cell responds to stress. The authors found that expression of >25% of all yeast genes is linearly correlated with growth rate, independent of the limiting nutrient. They also found that the subset of negatively growth-correlated genes is enriched for peroxisomal functions, and positively correlated genes mainly encode ribosomal functions.  
    Respond differently when different nutrients are being limited. If you see particular genes that respond very differently when a nutrient is sharply restricted, these genes might be involved in the transport or metabolism of that specific nutrient.
"
